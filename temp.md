## 第一部 Web 概論

### 第 2 章 Web の歴史

- ハイパーメディアとしての Web
  - Web はインターネットを使ったハイパーメディアとして設計された。インターネットを用いているため不特定多数の情報をリンクさせあうことができ、システムを大規模化しやすいという重要な利点をもつ。
  - Web が実現しているリンクは、シンプルな単方向リンクだけであるということ。
- 分散システムとしての Web
  - オープンで不特定多数を相手にするのが Web
  - クライアントとサーバの間のインターフェースを HTTP というシンプルなプロトコルで固定したことで実現されている。

### 第 3 章 REST

Web のアーキテクチャスタイルは REST でもあり、クライアント/サーバーでもある。

#### リソース

- Web 上の情報である
- 世界中の無数のリソースは、それぞれ URI で一位の名前を持つ
- URI を用いることで、プログラムはリソースが表現する情報にアクセスできる

#### クライアント/サーバー

- クライアントはサーバーにリクエストを送り、サーバーはクライアントにレスポンスを返す。

### ステートレスサーバー

- ステートレスとは、クライアントのアプリケーション状態をサーバーで管理しないことを意味する。
- REST の視点から見ると、Cookie を使用したステートフルなセッション管理が間違っているが、使用する際は、ステートレスサーバーの利点をあえて捨てることを理解した上で、必要最低限の仕様仕様にとどめる。

### キャッシュ

- リソースの鮮度に基づいて、一度取得したリソースをクライアント側で使い回す方式。
- キャッシュの利点は、サーバとクライアント間での通信を減らすことでネットワーク帯域の利用や処理時間を縮小し、より効率的に処理ができること。
- 古いキャッシュを使うと、情報の信頼性が落ちるので注意が必要。

### 統一インターフェース

- URI で指し示したリソースに対する操作を、統一した限定的なインターフェースで行うアーキテクチャスタイル。
- 例えば、HTTP1.1 のメソッドは 8 つに限定されている。

### 階層化システム

- ロードバランサーやプロキシを加え、システムを階層化して分離するアーキテクチャ。

### コードオンデマンド

- プログラムをクライアントにダウンロードして実行する。

## 第 2 部 URI

### 第 2 章 Web の歴史

- ハイパーメディアとしての Web
  - Web はインターネットを使ったハイパーメディアとして設計された。インターネットを用いているため不特定多数の情報をリンクさせあうことができ、システムを大規模化しやすいという重要な利点をもつ。
  - Web が実現しているリンクは、シンプルな単方向リンクだけであるということ。
- 分散システムとしての Web
  - オープンで不特定多数を相手にするのが Web
  - クライアントとサーバの間のインターフェースを HTTP というシンプルなプロトコルで固定したことで実現されている。

### 第 3 章 REST

Web のアーキテクチャスタイルは REST でもあり、クライアント/サーバーでもある。

### リソース

- Web 上の情報である
- 世界中の無数のリソースは、それぞれ URI で一位の名前を持つ
- URI を用いることで、プログラムはリソースが表現する情報にアクセスできる

### クライアント/サーバー

- クライアントはサーバーにリクエストを送り、サーバーはクライアントにレスポンスを返す。

### ステートレスサーバー

- ステートレスとは、クライアントのアプリケーション状態をサーバーで管理しないことを意味する。
- REST の視点から見ると、Cookie を使用したステートフルなセッション管理が間違っているが、使用する際は、ステートレスサーバーの利点をあえて捨てることを理解した上で、必要最低限の仕様仕様にとどめる。

### キャッシュ

- リソースの鮮度に基づいて、一度取得したリソースをクライアント側で使い回す方式。
- キャッシュの利点は、サーバとクライアント間での通信を減らすことでネットワーク帯域の利用や処理時間を縮小し、より効率的に処理ができること。
- 古いキャッシュを使うと、情報の信頼性が落ちるので注意が必要。

### 統一インターフェース

- URI で指し示したリソースに対する操作を、統一した限定的なインターフェースで行うアーキテクチャスタイル。
- 例えば、HTTP1.1 のメソッドは 8 つに限定されている。

### 階層化システム

- ロードバランサーやプロキシを加え、システムを階層化して分離するアーキテクチャ。

### コードオンデマンド

- プログラムをクライアントにダウンロードして実行する。

## 第 3 部 HTTP

### HTTP

- 名前こそハイパーテキストの転送用のプロトコルだが、コンピュータで扱うデータであればなんでも送れる
- REST の重要な特徴である統一インターフェース、ステートレスサーバ、キャッシュなどを実現している、Web の基盤となるプロトコル。

### TCP/IP

- インターネットの基盤を構成する重要なネットワークプロトコル。HTTP のベースとなっている。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e102b602-85c4-4f76-bda2-0dbd6910e3f8/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e61702d6e6f727468656173742d312e616d617a6f6e6177732e636f6d2f302f3337343535372f33356239373262622d616465302d386462332d343239302d3766323835303061303865382e706e67.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e102b602-85c4-4f76-bda2-0dbd6910e3f8/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e61702d6e6f727468656173742d312e616d617a6f6e6177732e636f6d2f302f3337343535372f33356239373262622d616465302d386462332d343239302d3766323835303061303865382e706e67.png)

[画像の参照元](https://qiita.com/kakkie/items/ac201ecd642d2e3a7b99)

### リクエストとレスポンス

#### クライアントで行われること

1. リクエストメッセージの構築
2. リクエストメッセージの送信
3. (レスポンスが返るまで待機)
4. レスポンスメッセージの受信
5. レスポンスメッセージの解析
6. クライアントの目的を達成するために必要な処理

#### サーバーで行われること

1. (リクエストの待機)
2. リクエストメッセージの受信
3. リクエストメッセージの解析
4. 適切なアプリケーションプログラムへの処理の委譲
5. アプリケーションプログラムから結果を取得
6. レスポンスメッセージの構築
7. レスポンスメッセージの送信

### リクエストメッセージ

- リクエストライン、ヘッダー、ボディからなる

### レスポンスメッセージ

- ステータスライン、ヘッダー、ボディからなる

### HTTP のステートレス性

#### ステートレス

- ステートレスとは「サーバがクライアントのアプリケーション状態を保持しない」制約
- ステートレスなやりとりは冗長
- ステートレスなやりとりでは、クライアントは毎回全ての注文を繰り返している
- (+)サーバがクライアントのセッション状態を覚える代わりに、クライアントが自らのセッション状態を覚え、全ての必要な情報をリクエストメッセージに含めて送信する。
- (-)送信するデータが多くなる
- (-)認証など、サーバに負荷がかかる処理を繰り返す

#### ステートフル

- ステートフルなやりとりは簡潔
- ステートフルなやりとりでは、サーバがクライアントのそれまでの注文を覚えている
- (-) クライアントの数が増えるとスケールアウトがさせにくい

#### セッション

システムにログインしてからログアウトするまでの一連の操作をまとめて「**セッション**」と呼ぶ。

この一連の操作の間の状態をセッション状態(アプリケーション状態)という。

### HTTP メソッド

1. **GET**: リソースの取得
2. **POST**: リソースの作成、追加
3. **PUT**: リソースの更新、作成
4. **DELETE**: リソースの削除
5. **HEAD**: リソースのヘッダの取得
6. **OPTIONS**: リソースがサポートしているメソッドの取得
7. TRACE: 自分宛にリクエストメッセージを返す試験
8. CONNECT: プロキシ動作のトンネル接続への変更

# ステータスコード

- **1xx**: 処理中
- **2xx**: 成功
- **3xx**: リダイレクト
- **4xx**: クライアントエラー
- **5xx**: サーバエラー

### HTTP ヘッダ

- ヘッダは、メッセージボディに対する付加的な情報(メタデータ)
- リソースへのアクセス権を設定する認証や、クライアントとサーバの通信回数を減らすキャッシュなどの HTTP の機能はヘッダで実現する。

### BASIC 認証と Digest 認証

**BASIC 認証:**

ユーザ名とパスワードによる認証方式。ユーザ名とパスワードを Authorization ヘッダに入れてリクエス トごとに送信する。簡単にデコードできるため、セキュリティレベルが低い。

**Digest 認証:**

BASIC 認証よりセキュア。メッセージに対してハッシュ関数を適用した結果のハッシュ値を使用する。

### キャッシュ

サーバから取得したリソースをローカルストレージ(ハードディスクなど)に蓄積し、再利用する手法のこと。クライアントが蓄積したキャッシュは、そのキャッシュが有効な間、クライアントが再度そのリソースにアクセスしようとした時に再利用する。

### キャッシュ用ヘッダ

クライアントはサーバから取得したリソースがキャッシュ可能であるかを調べ、可能な場合はローカルストレージに蓄積する。

- Pragma: キャッシュを抑制する
- Expires: キャッシュの有効期限を示す
- Cache-Control: 詳細なキャッシュ方法を指定する

### キャッシュ用ヘッダの使い分け

1. キャッシュさせない場合、Pragma と Cache-Control を no-cache に同時指定する。
2. キャッシュの有効期限が明確な場合、Expires 指定する。
3. キャッシュの有効期限を相対的に指定したい場合、Cache-Control の max-age で早退時間を指定する。

## 第 5 章 Web サービスの設計

### トランザクション

2 つの処理が成功するか、もしくは失敗した場合に元に戻すことを保証すること。

### 排他制御

複数のクライアントが同時に一つのリソースを編集して競合が起きないように、1 つのクライアントのみが編集するように制御する処理のことを言う。主に悲観的ロックと楽観ロックがある。

### 悲観的ロック

ユーザーをあまり信用せずに、競合が発生しないようにする排他制御の方法。HTTP で悲観ロックを実現するには WebDev の LOCK/UNLOCK メソッドを使う方法と、独自のロックリソースを使う方法がある。

### 楽観的ロック

常に同じ文章を複数人が同時に編集することはないと言う前提で、通常の編集では文書をロックはせずに、競合が起きた時に対処する仕組み。HTTP で楽観的ロックを実現するためには、条件付き PUT と条件付き DELETE を利用する。
